use serde::{Deserialize, Serialize};
use std::fmt;

/// Severity levels for security vulnerabilities.
///
/// Severity is ordered from [`Low`](Severity::Low) to [`Critical`](Severity::Critical),
/// allowing for comparison and sorting of vulnerabilities by their impact.
///
/// # Severity Guidelines
///
/// - **Critical**: Requires immediate attention. Exploitable vulnerabilities that
///   can lead to complete system compromise, data breaches, or remote code execution.
///   Examples: Exposed SSH keys, command injection, SQL injection.
///
/// - **High**: Serious vulnerabilities that should be addressed quickly. May not be
///   immediately exploitable but pose significant risk. Examples: Prompt injection,
///   tool poisoning, hardcoded passwords.
///
/// - **Medium**: Moderate risk vulnerabilities that should be fixed but don't pose
///   immediate danger. Examples: Weak cryptography, information disclosure.
///
/// - **Low**: Minor issues or best practice violations. Examples: Missing input
///   validation, verbose error messages.
///
/// # Examples
///
/// ```
/// use mcp_sentinel::Severity;
///
/// let critical = Severity::Critical;
/// let high = Severity::High;
///
/// assert!(critical > high);
/// assert_eq!(critical.badge(), "ðŸ”´");
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Severity {
    /// Low severity - minor issues or best practice violations
    Low,
    /// Medium severity - moderate risk vulnerabilities
    Medium,
    /// High severity - serious vulnerabilities requiring prompt attention
    High,
    /// Critical severity - exploitable vulnerabilities requiring immediate action
    Critical,
}

impl fmt::Display for Severity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Severity::Low => write!(f, "LOW"),
            Severity::Medium => write!(f, "MEDIUM"),
            Severity::High => write!(f, "HIGH"),
            Severity::Critical => write!(f, "CRITICAL"),
        }
    }
}

impl Severity {
    /// Get emoji badge for severity level.
    ///
    /// Returns a colored circle emoji representing the severity:
    /// - ðŸ”´ Critical
    /// - ðŸŸ  High
    /// - ðŸŸ¡ Medium
    /// - ðŸ”µ Low
    ///
    /// # Examples
    ///
    /// ```
    /// use mcp_sentinel::Severity;
    ///
    /// assert_eq!(Severity::Critical.badge(), "ðŸ”´");
    /// assert_eq!(Severity::Low.badge(), "ðŸ”µ");
    /// ```
    pub fn badge(&self) -> &'static str {
        match self {
            Severity::Low => "ðŸ”µ",
            Severity::Medium => "ðŸŸ¡",
            Severity::High => "ðŸŸ ",
            Severity::Critical => "ðŸ”´",
        }
    }

    /// Parse severity from string (case-insensitive).
    ///
    /// Accepts "low", "medium", "high", or "critical" in any case.
    ///
    /// # Examples
    ///
    /// ```
    /// use mcp_sentinel::Severity;
    ///
    /// assert_eq!(Severity::from_str("critical"), Some(Severity::Critical));
    /// assert_eq!(Severity::from_str("HIGH"), Some(Severity::High));
    /// assert_eq!(Severity::from_str("invalid"), None);
    /// ```
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "low" => Some(Severity::Low),
            "medium" => Some(Severity::Medium),
            "high" => Some(Severity::High),
            "critical" => Some(Severity::Critical),
            _ => None,
        }
    }
}

/// Types of vulnerabilities detected
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum VulnerabilityType {
    /// Hidden malicious instructions in MCP tool descriptions
    ToolPoisoning,
    /// Prompt injection attempts to manipulate AI behavior
    PromptInjection,
    /// Exposure of sensitive files or credentials
    SensitiveDataExposure,
    /// Unauthorized transmission of sensitive data
    DataExfiltration,
    /// Dangerous sequences of tool calls
    ToxicFlow,
    /// Tools that change behavior after initial approval
    RugPull,
    /// Undocumented or hidden tools
    ShadowTool,
    /// OS command injection vulnerabilities
    CommandInjection,
    /// Path traversal allowing unauthorized file access
    PathTraversal,
    /// SQL injection vulnerabilities
    SqlInjection,
    /// Insecure deserialization of untrusted data
    UnsafeDeserialization,
    /// Hardcoded credentials in source code
    HardcodedCredentials,
    /// Server-side request forgery
    Ssrf,
    /// XML external entity injection
    Xxe,
    /// Leaked API keys, tokens, or passwords
    SecretsLeakage,
    /// Exposure of personally identifiable information
    PiiExposure,
    /// Privilege escalation through tool chaining
    CrossOriginEscalation,
    /// Unusual patterns in tool usage
    BehavioralAnomaly,
    /// Vulnerable dependencies or supply chain issues
    SupplyChainVulnerability,
}

impl fmt::Display for VulnerabilityType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            VulnerabilityType::ToolPoisoning => "Tool Poisoning",
            VulnerabilityType::PromptInjection => "Prompt Injection",
            VulnerabilityType::SensitiveDataExposure => "Sensitive Data Exposure",
            VulnerabilityType::DataExfiltration => "Data Exfiltration",
            VulnerabilityType::ToxicFlow => "Toxic Flow",
            VulnerabilityType::RugPull => "MCP Rug Pull",
            VulnerabilityType::ShadowTool => "Shadow Tool",
            VulnerabilityType::CommandInjection => "Command Injection",
            VulnerabilityType::PathTraversal => "Path Traversal",
            VulnerabilityType::SqlInjection => "SQL Injection",
            VulnerabilityType::UnsafeDeserialization => "Unsafe Deserialization",
            VulnerabilityType::HardcodedCredentials => "Hardcoded Credentials",
            VulnerabilityType::Ssrf => "Server-Side Request Forgery",
            VulnerabilityType::Xxe => "XML External Entity",
            VulnerabilityType::SecretsLeakage => "Secrets Leakage",
            VulnerabilityType::PiiExposure => "PII Exposure",
            VulnerabilityType::CrossOriginEscalation => "Cross-Origin Escalation",
            VulnerabilityType::BehavioralAnomaly => "Behavioral Anomaly",
            VulnerabilityType::SupplyChainVulnerability => "Supply Chain Vulnerability",
        };
        write!(f, "{}", s)
    }
}

/// Location of a vulnerability in source code.
///
/// Represents where a vulnerability was found, with optional line and column numbers.
///
/// # Examples
///
/// ```
/// use mcp_sentinel::models::vulnerability::Location;
///
/// let loc = Location {
///     file: "server.py".to_string(),
///     line: Some(42),
///     column: Some(10),
/// };
/// assert_eq!(loc.to_string(), "server.py:42:10");
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Location {
    /// File path where vulnerability was found
    pub file: String,
    /// Line number (1-indexed), if available
    pub line: Option<usize>,
    /// Column number (1-indexed), if available
    pub column: Option<usize>,
}

impl fmt::Display for Location {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (self.line, self.column) {
            (Some(line), Some(col)) => write!(f, "{}:{}:{}", self.file, line, col),
            (Some(line), None) => write!(f, "{}:{}", self.file, line),
            _ => write!(f, "{}", self.file),
        }
    }
}

/// Evidence supporting a vulnerability detection.
///
/// Contains the code snippet or pattern that triggered the detection,
/// along with additional contextual information stored as JSON.
///
/// # Examples
///
/// ```
/// use mcp_sentinel::models::vulnerability::Evidence;
/// use serde_json::json;
///
/// let evidence = Evidence {
///     snippet: Some("api_key = 'sk-123456'".to_string()),
///     context: json!({
///         "line_number": 42,
///         "secret_type": "API Key"
///     }),
/// };
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Evidence {
    /// Code snippet or pattern that triggered detection
    pub snippet: Option<String>,

    /// Additional context as flexible JSON
    #[serde(flatten)]
    pub context: serde_json::Value,
}

/// AI-powered analysis results for a vulnerability.
///
/// When AI analysis is enabled, this provides natural language explanations
/// of why the vulnerability is dangerous and contextual risk assessment.
///
/// # Examples
///
/// ```
/// use mcp_sentinel::models::vulnerability::AiAnalysis;
///
/// let analysis = AiAnalysis {
///     model: "gpt-4".to_string(),
///     explanation: "This tool description contains hidden instructions...".to_string(),
///     confidence: 0.95,
/// };
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AiAnalysis {
    /// LLM model used for analysis (e.g., "gpt-4", "claude-3-opus")
    pub model: String,

    /// Natural language explanation of the vulnerability
    pub explanation: String,

    /// Confidence score (0.0 to 1.0)
    pub confidence: f64,
}

/// A detected security vulnerability.
///
/// Represents a complete vulnerability finding including metadata, location,
/// severity assessment, and remediation guidance.
///
/// # Builder Pattern
///
/// Use the builder methods to construct a vulnerability with all relevant information:
///
/// ```
/// use mcp_sentinel::{Vulnerability, VulnerabilityType, Severity};
/// use mcp_sentinel::models::vulnerability::Evidence;
/// use serde_json::json;
///
/// let vuln = Vulnerability::new(
///     "SEC-001".to_string(),
///     VulnerabilityType::SecretsLeakage,
///     Severity::Critical,
///     "Exposed API Key".to_string(),
///     "GitHub token found in source code".to_string(),
/// )
/// .with_location("config.py".to_string(), Some(12), None)
/// .with_impact("Unauthorized access to GitHub repositories".to_string())
/// .with_remediation("Remove the token and rotate credentials immediately".to_string())
/// .with_evidence(Evidence {
///     snippet: Some("[REDACTED]".to_string()),
///     context: json!({"token_type": "GitHub PAT"}),
/// })
/// .with_cwe(798); // CWE-798: Use of Hard-coded Credentials
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Unique identifier (e.g., "C-001", "SEC-042")
    pub id: String,

    /// Type of vulnerability
    #[serde(rename = "type")]
    pub vuln_type: VulnerabilityType,

    /// Severity level
    pub severity: Severity,

    /// Confidence in detection (0.0 to 1.0, default 1.0)
    pub confidence: f64,

    /// Location in source code, if applicable
    pub location: Option<Location>,

    /// Short, descriptive title
    pub title: String,

    /// Detailed description of the issue
    pub description: String,

    /// Explanation of potential impact
    pub impact: String,

    /// Recommended remediation steps
    pub remediation: String,

    /// Supporting evidence for the detection
    pub evidence: Option<Evidence>,

    /// AI-powered analysis, if available
    pub ai_analysis: Option<AiAnalysis>,

    /// CWE (Common Weakness Enumeration) ID, if applicable
    pub cwe: Option<u32>,

    /// CVSS (Common Vulnerability Scoring System) score, if applicable
    pub cvss: Option<f32>,
}

impl Vulnerability {
    /// Create a new vulnerability with required fields.
    ///
    /// Additional details can be added using the builder methods.
    ///
    /// # Arguments
    ///
    /// * `id` - Unique identifier for this vulnerability
    /// * `vuln_type` - Category of vulnerability
    /// * `severity` - Severity level
    /// * `title` - Short, descriptive title
    /// * `description` - Detailed description
    ///
    /// # Examples
    ///
    /// ```
    /// use mcp_sentinel::{Vulnerability, VulnerabilityType, Severity};
    ///
    /// let vuln = Vulnerability::new(
    ///     "TP-001".to_string(),
    ///     VulnerabilityType::ToolPoisoning,
    ///     Severity::Critical,
    ///     "Hidden Instructions in Tool".to_string(),
    ///     "Tool contains concealed malicious instructions".to_string(),
    /// );
    /// ```
    pub fn new(
        id: String,
        vuln_type: VulnerabilityType,
        severity: Severity,
        title: String,
        description: String,
    ) -> Self {
        Self {
            id,
            vuln_type,
            severity,
            confidence: 1.0,
            location: None,
            title,
            description,
            impact: String::new(),
            remediation: String::new(),
            evidence: None,
            ai_analysis: None,
            cwe: None,
            cvss: None,
        }
    }

    /// Set the location where the vulnerability was found.
    ///
    /// # Examples
    ///
    /// ```
    /// use mcp_sentinel::{Vulnerability, VulnerabilityType, Severity};
    ///
    /// let vuln = Vulnerability::new(
    ///     "SEC-001".to_string(),
    ///     VulnerabilityType::SecretsLeakage,
    ///     Severity::Critical,
    ///     "Exposed Secret".to_string(),
    ///     "API key found in code".to_string(),
    /// )
    /// .with_location("config.py".to_string(), Some(42), Some(15));
    /// ```
    pub fn with_location(mut self, file: String, line: Option<usize>, column: Option<usize>) -> Self {
        self.location = Some(Location { file, line, column });
        self
    }

    /// Set the impact explanation.
    ///
    /// Describes what an attacker could do if they exploit this vulnerability.
    pub fn with_impact(mut self, impact: String) -> Self {
        self.impact = impact;
        self
    }

    /// Set the remediation advice.
    ///
    /// Provides concrete steps to fix the vulnerability.
    pub fn with_remediation(mut self, remediation: String) -> Self {
        self.remediation = remediation;
        self
    }

    /// Set the supporting evidence.
    ///
    /// Includes code snippets and additional context about the detection.
    pub fn with_evidence(mut self, evidence: Evidence) -> Self {
        self.evidence = Some(evidence);
        self
    }

    /// Set the AI analysis results.
    ///
    /// Adds natural language explanation from an LLM.
    pub fn with_ai_analysis(mut self, ai_analysis: AiAnalysis) -> Self {
        self.ai_analysis = Some(ai_analysis);
        self
    }

    /// Set the confidence score.
    ///
    /// # Arguments
    ///
    /// * `confidence` - Value between 0.0 and 1.0, where 1.0 is highest confidence
    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence;
        self
    }

    /// Set the CWE (Common Weakness Enumeration) ID.
    ///
    /// See <https://cwe.mitre.org/> for the full CWE list.
    ///
    /// # Examples
    ///
    /// ```
    /// use mcp_sentinel::{Vulnerability, VulnerabilityType, Severity};
    ///
    /// let vuln = Vulnerability::new(
    ///     "SEC-001".to_string(),
    ///     VulnerabilityType::CommandInjection,
    ///     Severity::Critical,
    ///     "OS Command Injection".to_string(),
    ///     "Unsanitized input passed to system command".to_string(),
    /// )
    /// .with_cwe(78); // CWE-78: OS Command Injection
    /// ```
    pub fn with_cwe(mut self, cwe: u32) -> Self {
        self.cwe = Some(cwe);
        self
    }

    /// Set the CVSS (Common Vulnerability Scoring System) score.
    ///
    /// # Arguments
    ///
    /// * `cvss` - Score between 0.0 and 10.0
    pub fn with_cvss(mut self, cvss: f32) -> Self {
        self.cvss = Some(cvss);
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
    }

    #[test]
    fn test_severity_from_str() {
        assert_eq!(Severity::from_str("low"), Some(Severity::Low));
        assert_eq!(Severity::from_str("MEDIUM"), Some(Severity::Medium));
        assert_eq!(Severity::from_str("High"), Some(Severity::High));
        assert_eq!(Severity::from_str("CRITICAL"), Some(Severity::Critical));
        assert_eq!(Severity::from_str("invalid"), None);
    }

    #[test]
    fn test_location_display() {
        let loc = Location {
            file: "test.py".to_string(),
            line: Some(42),
            column: Some(10),
        };
        assert_eq!(loc.to_string(), "test.py:42:10");

        let loc2 = Location {
            file: "test.py".to_string(),
            line: Some(42),
            column: None,
        };
        assert_eq!(loc2.to_string(), "test.py:42");
    }

    #[test]
    fn test_vulnerability_builder() {
        let vuln = Vulnerability::new(
            "C-001".to_string(),
            VulnerabilityType::ToolPoisoning,
            Severity::Critical,
            "Test Vulnerability".to_string(),
            "A test vulnerability".to_string(),
        )
        .with_location("test.py".to_string(), Some(10), None)
        .with_impact("High impact".to_string())
        .with_remediation("Fix it".to_string())
        .with_confidence(0.95);

        assert_eq!(vuln.severity, Severity::Critical);
        assert_eq!(vuln.confidence, 0.95);
        assert!(vuln.location.is_some());
    }
}
