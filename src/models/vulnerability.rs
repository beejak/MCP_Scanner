use serde::{Deserialize, Serialize};
use std::fmt;

/// Severity levels for security vulnerabilities.
///
/// Severity is ordered from [`Low`](Severity::Low) to [`Critical`](Severity::Critical),
/// allowing for comparison and sorting of vulnerabilities by their impact.
///
/// # Severity Guidelines
///
/// - **Critical**: Requires immediate attention. Exploitable vulnerabilities that
///   can lead to complete system compromise, data breaches, or remote code execution.
///   Examples: Exposed SSH keys, command injection, SQL injection.
///
/// - **High**: Serious vulnerabilities that should be addressed quickly. May not be
///   immediately exploitable but pose significant risk. Examples: Prompt injection,
///   tool poisoning, hardcoded passwords.
///
/// - **Medium**: Moderate risk vulnerabilities that should be fixed but don't pose
///   immediate danger. Examples: Weak cryptography, information disclosure.
///
/// - **Low**: Minor issues or best practice violations. Examples: Missing input
///   validation, verbose error messages.
///
/// # Examples
///
/// ```
/// use mcp_sentinel::Severity;
///
/// let critical = Severity::Critical;
/// let high = Severity::High;
///
/// assert!(critical > high);
/// assert_eq!(critical.badge(), "ðŸ”´");
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Severity {
    /// Low severity - minor issues or best practice violations
    Low,
    /// Medium severity - moderate risk vulnerabilities
    Medium,
    /// High severity - serious vulnerabilities requiring prompt attention
    High,
    /// Critical severity - exploitable vulnerabilities requiring immediate action
    Critical,
}

impl fmt::Display for Severity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Severity::Low => write!(f, "LOW"),
            Severity::Medium => write!(f, "MEDIUM"),
            Severity::High => write!(f, "HIGH"),
            Severity::Critical => write!(f, "CRITICAL"),
        }
    }
}

impl Severity {
    /// Get emoji badge for severity level.
    ///
    /// Returns a colored circle emoji representing the severity:
    /// - ðŸ”´ Critical
    /// - ðŸŸ  High
    /// - ðŸŸ¡ Medium
    /// - ðŸ”µ Low
    ///
    /// # Examples
    ///
    /// ```
    /// use mcp_sentinel::Severity;
    ///
    /// assert_eq!(Severity::Critical.badge(), "ðŸ”´");
    /// assert_eq!(Severity::Low.badge(), "ðŸ”µ");
    /// ```
    pub fn badge(&self) -> &'static str {
        match self {
            Severity::Low => "ðŸ”µ",
            Severity::Medium => "ðŸŸ¡",
            Severity::High => "ðŸŸ ",
            Severity::Critical => "ðŸ”´",
        }
    }

    /// Parse severity from string (case-insensitive).
    ///
    /// Accepts "low", "medium", "high", or "critical" in any case.
    ///
    /// # Examples
    ///
    /// ```
    /// use mcp_sentinel::Severity;
    ///
    /// assert_eq!(Severity::from_str("critical"), Some(Severity::Critical));
    /// assert_eq!(Severity::from_str("HIGH"), Some(Severity::High));
    /// assert_eq!(Severity::from_str("invalid"), None);
    /// ```
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "low" => Some(Severity::Low),
            "medium" => Some(Severity::Medium),
            "high" => Some(Severity::High),
            "critical" => Some(Severity::Critical),
            _ => None,
        }
    }
}

/// Types of vulnerabilities detected
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum VulnerabilityType {
    /// Hidden malicious instructions in MCP tool descriptions
    ToolPoisoning,
    /// Prompt injection attempts to manipulate AI behavior
    PromptInjection,
    /// Exposure of sensitive files or credentials
    SensitiveDataExposure,
    /// Unauthorized transmission of sensitive data
    DataExfiltration,
    /// Dangerous sequences of tool calls
    ToxicFlow,
    /// Tools that change behavior after initial approval
    RugPull,
    /// Undocumented or hidden tools
    ShadowTool,
    /// OS command injection vulnerabilities
    CommandInjection,
    /// Path traversal allowing unauthorized file access
    PathTraversal,
    /// SQL injection vulnerabilities
    SqlInjection,
    /// Insecure deserialization of untrusted data
    UnsafeDeserialization,
    /// Hardcoded credentials in source code
    HardcodedCredentials,
    /// Server-side request forgery
    Ssrf,
    /// XML external entity injection
    Xxe,
    /// Leaked API keys, tokens, or passwords
    SecretsLeakage,
    /// Exposure of personally identifiable information
    PiiExposure,
    /// Privilege escalation through tool chaining
    CrossOriginEscalation,
    /// Unusual patterns in tool usage
    BehavioralAnomaly,
    /// Vulnerable dependencies or supply chain issues
    SupplyChainVulnerability,
}

impl fmt::Display for VulnerabilityType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            VulnerabilityType::ToolPoisoning => "Tool Poisoning",
            VulnerabilityType::PromptInjection => "Prompt Injection",
            VulnerabilityType::SensitiveDataExposure => "Sensitive Data Exposure",
            VulnerabilityType::DataExfiltration => "Data Exfiltration",
            VulnerabilityType::ToxicFlow => "Toxic Flow",
            VulnerabilityType::RugPull => "MCP Rug Pull",
            VulnerabilityType::ShadowTool => "Shadow Tool",
            VulnerabilityType::CommandInjection => "Command Injection",
            VulnerabilityType::PathTraversal => "Path Traversal",
            VulnerabilityType::SqlInjection => "SQL Injection",
            VulnerabilityType::UnsafeDeserialization => "Unsafe Deserialization",
            VulnerabilityType::HardcodedCredentials => "Hardcoded Credentials",
            VulnerabilityType::Ssrf => "Server-Side Request Forgery",
            VulnerabilityType::Xxe => "XML External Entity",
            VulnerabilityType::SecretsLeakage => "Secrets Leakage",
            VulnerabilityType::PiiExposure => "PII Exposure",
            VulnerabilityType::CrossOriginEscalation => "Cross-Origin Escalation",
            VulnerabilityType::BehavioralAnomaly => "Behavioral Anomaly",
            VulnerabilityType::SupplyChainVulnerability => "Supply Chain Vulnerability",
        };
        write!(f, "{}", s)
    }
}

/// Location of vulnerability in source code
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Location {
    pub file: String,
    pub line: Option<usize>,
    pub column: Option<usize>,
}

impl fmt::Display for Location {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (self.line, self.column) {
            (Some(line), Some(col)) => write!(f, "{}:{}:{}", self.file, line, col),
            (Some(line), None) => write!(f, "{}:{}", self.file, line),
            _ => write!(f, "{}", self.file),
        }
    }
}

/// Evidence supporting the vulnerability detection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Evidence {
    /// Code snippet or pattern that triggered detection
    pub snippet: Option<String>,

    /// Additional context
    #[serde(flatten)]
    pub context: serde_json::Value,
}

/// AI-powered analysis results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AiAnalysis {
    /// LLM model used for analysis
    pub model: String,

    /// Natural language explanation
    pub explanation: String,

    /// Confidence score (0.0 to 1.0)
    pub confidence: f64,
}

/// Complete vulnerability report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Unique identifier (e.g., "C-001")
    pub id: String,

    /// Type of vulnerability
    #[serde(rename = "type")]
    pub vuln_type: VulnerabilityType,

    /// Severity level
    pub severity: Severity,

    /// Confidence in detection (0.0 to 1.0)
    pub confidence: f64,

    /// Location in source code
    pub location: Option<Location>,

    /// Short title
    pub title: String,

    /// Detailed description
    pub description: String,

    /// Impact explanation
    pub impact: String,

    /// Remediation advice
    pub remediation: String,

    /// Supporting evidence
    pub evidence: Option<Evidence>,

    /// AI analysis (if available)
    pub ai_analysis: Option<AiAnalysis>,

    /// CWE ID if applicable
    pub cwe: Option<u32>,

    /// CVSS score if applicable
    pub cvss: Option<f32>,
}

impl Vulnerability {
    /// Create a new vulnerability
    pub fn new(
        id: String,
        vuln_type: VulnerabilityType,
        severity: Severity,
        title: String,
        description: String,
    ) -> Self {
        Self {
            id,
            vuln_type,
            severity,
            confidence: 1.0,
            location: None,
            title,
            description,
            impact: String::new(),
            remediation: String::new(),
            evidence: None,
            ai_analysis: None,
            cwe: None,
            cvss: None,
        }
    }

    /// Set location
    pub fn with_location(mut self, file: String, line: Option<usize>, column: Option<usize>) -> Self {
        self.location = Some(Location { file, line, column });
        self
    }

    /// Set impact
    pub fn with_impact(mut self, impact: String) -> Self {
        self.impact = impact;
        self
    }

    /// Set remediation
    pub fn with_remediation(mut self, remediation: String) -> Self {
        self.remediation = remediation;
        self
    }

    /// Set evidence
    pub fn with_evidence(mut self, evidence: Evidence) -> Self {
        self.evidence = Some(evidence);
        self
    }

    /// Set AI analysis
    pub fn with_ai_analysis(mut self, ai_analysis: AiAnalysis) -> Self {
        self.ai_analysis = Some(ai_analysis);
        self
    }

    /// Set confidence
    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence;
        self
    }

    /// Set CWE
    pub fn with_cwe(mut self, cwe: u32) -> Self {
        self.cwe = Some(cwe);
        self
    }

    /// Set CVSS
    pub fn with_cvss(mut self, cvss: f32) -> Self {
        self.cvss = Some(cvss);
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
    }

    #[test]
    fn test_severity_from_str() {
        assert_eq!(Severity::from_str("low"), Some(Severity::Low));
        assert_eq!(Severity::from_str("MEDIUM"), Some(Severity::Medium));
        assert_eq!(Severity::from_str("High"), Some(Severity::High));
        assert_eq!(Severity::from_str("CRITICAL"), Some(Severity::Critical));
        assert_eq!(Severity::from_str("invalid"), None);
    }

    #[test]
    fn test_location_display() {
        let loc = Location {
            file: "test.py".to_string(),
            line: Some(42),
            column: Some(10),
        };
        assert_eq!(loc.to_string(), "test.py:42:10");

        let loc2 = Location {
            file: "test.py".to_string(),
            line: Some(42),
            column: None,
        };
        assert_eq!(loc2.to_string(), "test.py:42");
    }

    #[test]
    fn test_vulnerability_builder() {
        let vuln = Vulnerability::new(
            "C-001".to_string(),
            VulnerabilityType::ToolPoisoning,
            Severity::Critical,
            "Test Vulnerability".to_string(),
            "A test vulnerability".to_string(),
        )
        .with_location("test.py".to_string(), Some(10), None)
        .with_impact("High impact".to_string())
        .with_remediation("Fix it".to_string())
        .with_confidence(0.95);

        assert_eq!(vuln.severity, Severity::Critical);
        assert_eq!(vuln.confidence, 0.95);
        assert!(vuln.location.is_some());
    }
}
